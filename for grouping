[33mcommit 1f45dc9c592e77707bcdaa0f36e977ef39df61c4[m[33m ([m[1;36mHEAD[m[33m -> [m[1;32mcopilot/fix-1[m[33m, [m[1;31morigin/copilot/fix-1[m[33m)[m
Author: copilot-swe-agent[bot] <198982749+Copilot@users.noreply.github.com>
Date:   Fri Jun 13 16:46:52 2025 +0000

    Convert AXI4-Lite GPIO from SystemVerilog to Verilog
    
    Co-authored-by: helium729 <30749877+helium729@users.noreply.github.com>

[1mdiff --git a/ip_cores/axi_lite_gpio/docs/README.md b/ip_cores/axi_lite_gpio/docs/README.md[m
[1mindex 75a406f..fd221a3 100644[m
[1m--- a/ip_cores/axi_lite_gpio/docs/README.md[m
[1m+++ b/ip_cores/axi_lite_gpio/docs/README.md[m
[36m@@ -36,9 +36,11 @@[m [mComplete AXI4-Lite slave interface including:[m
 - Read Data Channel: `s_axi_rdata`, `s_axi_rresp`, `s_axi_rvalid`, `s_axi_rready`[m
 [m
 ### GPIO Interface[m
[31m-- `gpio_i[NUM_CHANNELS-1:0][GPIO_WIDTH-1:0]` - GPIO input pins[m
[31m-- `gpio_o[NUM_CHANNELS-1:0][GPIO_WIDTH-1:0]` - GPIO output pins  [m
[31m-- `gpio_t[NUM_CHANNELS-1:0][GPIO_WIDTH-1:0]` - GPIO tristate control (1=input, 0=output)[m
[32m+[m[32m- `gpio_i[GPIO_WIDTH*NUM_CHANNELS-1:0]` - GPIO input pins (flattened array)[m
[32m+[m[32m- `gpio_o[GPIO_WIDTH*NUM_CHANNELS-1:0]` - GPIO output pins (flattened array)[m[41m  [m
[32m+[m[32m- `gpio_t[GPIO_WIDTH*NUM_CHANNELS-1:0]` - GPIO tristate control (1=input, 0=output) (flattened array)[m
[32m+[m
[32m+[m[32m**Note**: The GPIO signals are organized as flattened arrays where Channel 0 occupies bits [GPIO_WIDTH-1:0] and Channel 1 (if present) occupies bits [GPIO_WIDTH*2-1:GPIO_WIDTH].[m
 [m
 ## Register Map[m
 [m
[36m@@ -66,9 +68,9 @@[m [mComplete AXI4-Lite slave interface including:[m
 [m
 ## Usage Example[m
 [m
[31m-### SystemVerilog Instantiation[m
[32m+[m[32m### Verilog Instantiation[m
 [m
[31m-```systemverilog[m
[32m+[m[32m```verilog[m
 axi_lite_gpio #([m
     .GPIO_WIDTH(16),      // 16-bit GPIO[m
     .NUM_CHANNELS(2),     // 2 channels[m
[1mdiff --git a/ip_cores/axi_lite_gpio/rtl/axi_lite_gpio.sv b/ip_cores/axi_lite_gpio/rtl/axi_lite_gpio.sv[m
[1mdeleted file mode 100644[m
[1mindex c0d40cd..0000000[m
[1m--- a/ip_cores/axi_lite_gpio/rtl/axi_lite_gpio.sv[m
[1m+++ /dev/null[m
[36m@@ -1,269 +0,0 @@[m
[31m-/*[m
[31m- * AXI4-Lite GPIO Controller[m
[31m- * [m
[31m- * This module implements a configurable GPIO controller with AXI4-Lite slave interface.[m
[31m- * Features:[m
[31m- * - Configurable width (1 to 32 bits) and direction at compile time[m
[31m- * - Support for up to 2 channels[m
[31m- * - Individual pin direction control (input/output)[m
[31m- * - AXI4-Lite compliant slave interface[m
[31m- * [m
[31m- * Register Map:[m
[31m- * 0x00: Channel 0 Data Register (R/W)[m
[31m- * 0x04: Channel 0 Direction Register (R/W) - 1=output, 0=input[m
[31m- * 0x08: Channel 1 Data Register (R/W) - if NUM_CHANNELS > 1[m
[31m- * 0x0C: Channel 1 Direction Register (R/W) - if NUM_CHANNELS > 1[m
[31m- */[m
[31m-[m
[31m-module axi_lite_gpio #([m
[31m-    parameter int GPIO_WIDTH = 8,           // Width of each GPIO channel (1-32)[m
[31m-    parameter int NUM_CHANNELS = 1,         // Number of GPIO channels (1-2)[m
[31m-    parameter int ADDR_WIDTH = 4            // AXI address width (minimum 4 for register map)[m
[31m-) ([m
[31m-    // Clock and Reset[m
[31m-    input  logic                    aclk,[m
[31m-    input  logic                    aresetn,[m
[31m-    [m
[31m-    // AXI4-Lite Slave Interface[m
[31m-    // Write Address Channel[m
[31m-    input  logic [ADDR_WIDTH-1:0]  s_axi_awaddr,[m
[31m-    input  logic [2:0]             s_axi_awprot,[m
[31m-    input  logic                   s_axi_awvalid,[m
[31m-    output logic                   s_axi_awready,[m
[31m-    [m
[31m-    // Write Data Channel  [m
[31m-    input  logic [31:0]            s_axi_wdata,[m
[31m-    input  logic [3:0]             s_axi_wstrb,[m
[31m-    input  logic                   s_axi_wvalid,[m
[31m-    output logic                   s_axi_wready,[m
[31m-    [m
[31m-    // Write Response Channel[m
[31m-    output logic [1:0]             s_axi_bresp,[m
[31m-    output logic                   s_axi_bvalid,[m
[31m-    input  logic                   s_axi_bready,[m
[31m-    [m
[31m-    // Read Address Channel[m
[31m-    input  logic [ADDR_WIDTH-1:0]  s_axi_araddr,[m
[31m-    input  logic [2:0]             s_axi_arprot,[m
[31m-    input  logic                   s_axi_arvalid,[m
[31m-    output logic                   s_axi_arready,[m
[31m-    [m
[31m-    // Read Data Channel[m
[31m-    output logic [31:0]            s_axi_rdata,[m
[31m-    output logic [1:0]             s_axi_rresp,[m
[31m-    output logic                   s_axi_rvalid,[m
[31m-    input  logic                   s_axi_rready,[m
[31m-    [m
[31m-    // GPIO Interface[m
[31m-    input  logic [GPIO_WIDTH-1:0]  gpio_i [NUM_CHANNELS-1:0],   // GPIO input[m
[31m-    output logic [GPIO_WIDTH-1:0]  gpio_o [NUM_CHANNELS-1:0],   // GPIO output  [m
[31m-    output logic [GPIO_WIDTH-1:0]  gpio_t [NUM_CHANNELS-1:0]    // GPIO tristate (1=input, 0=output)[m
[31m-);[m
[31m-[m
[31m-    // Parameter validation[m
[31m-    initial begin[m
[31m-        if (GPIO_WIDTH < 1 || GPIO_WIDTH > 32) begin[m
[31m-            $error("GPIO_WIDTH must be between 1 and 32, got %0d", GPIO_WIDTH);[m
[31m-        end[m
[31m-        if (NUM_CHANNELS < 1 || NUM_CHANNELS > 2) begin[m
[31m-            $error("NUM_CHANNELS must be 1 or 2, got %0d", NUM_CHANNELS);[m
[31m-        end[m
[31m-        if (ADDR_WIDTH < 4) begin[m
[31m-            $error("ADDR_WIDTH must be at least 4 for register map, got %0d", ADDR_WIDTH);[m
[31m-        end[m
[31m-    end[m
[31m-[m
[31m-    // Internal registers[m
[31m-    logic [GPIO_WIDTH-1:0] gpio_data_reg [NUM_CHANNELS-1:0];  // Data registers[m
[31m-    logic [GPIO_WIDTH-1:0] gpio_dir_reg [NUM_CHANNELS-1:0];   // Direction registers (1=output, 0=input)[m
[31m-    [m
[31m-    // AXI4-Lite interface signals[m
[31m-    logic                  axi_awready;[m
[31m-    logic                  axi_wready;[m
[31m-    logic [1:0]            axi_bresp;[m
[31m-    logic                  axi_bvalid;[m
[31m-    logic                  axi_arready;[m
[31m-    logic [31:0]           axi_rdata;[m
[31m-    logic [1:0]            axi_rresp;[m
[31m-    logic                  axi_rvalid;[m
[31m-    [m
[31m-    // Internal address registers[m
[31m-    logic [ADDR_WIDTH-1:0] axi_awaddr;[m
[31m-    logic [ADDR_WIDTH-1:0] axi_araddr;[m
[31m-    [m
[31m-    // AXI4-Lite Write Address Channel[m
[31m-    always_ff @(posedge aclk) begin[m
[31m-        if (!aresetn) begin[m
[31m-            axi_awready <= 1'b0;[m
[31m-            axi_awaddr <= '0;[m
[31m-        end else begin[m
[31m-            if (~axi_awready && s_axi_awvalid && s_axi_wvalid) begin[m
[31m-                axi_awready <= 1'b1;[m
[31m-                axi_awaddr <= s_axi_awaddr;[m
[31m-            end else begin[m
[31m-                axi_awready <= 1'b0;[m
[31m-            end[m
[31m-        end[m
[31m-    end[m
[31m-    [m
[31m-    // AXI4-Lite Write Data Channel[m
[31m-    always_ff @(posedge aclk) begin[m
[31m-        if (!aresetn) begin[m
[31m-            axi_wready <= 1'b0;[m
[31m-        end else begin[m
[31m-            if (~axi_wready && s_axi_wvalid && s_axi_awvalid) begin[m
[31m-                axi_wready <= 1'b1;[m
[31m-            end else begin[m
[31m-                axi_wready <= 1'b0;[m
[31m-            end[m
[31m-        end[m
[31m-    end[m
[31m-    [m
[31m-    // Register writes[m
[31m-    always_ff @(posedge aclk) begin[m
[31m-        if (!aresetn) begin[m
[31m-            for (int i = 0; i < NUM_CHANNELS; i++) begin[m
[31m-                gpio_data_reg[i] <= '0;[m
[31m-                gpio_dir_reg[i] <= '0;  // Default to all inputs[m
[31m-            end[m
[31m-        end else begin[m
[31m-            if (axi_wready && s_axi_wvalid && axi_awready && s_axi_awvalid) begin[m
[31m-                case (axi_awaddr[3:2])[m
[31m-                    2'b00: begin  // Channel 0 Data Register[m
[31m-                        if (s_axi_wstrb[0]) gpio_data_reg[0][7:0] <= s_axi_wdata[7:0];[m
[31m-                        if (s_axi_wstrb[1] && GPIO_WIDTH > 8) gpio_data_reg[0][15:8] <= s_axi_wdata[15:8];[m
[31m-                        if (s_axi_wstrb[2] && GPIO_WIDTH > 16) gpio_data_reg[0][23:16] <= s_axi_wdata[23:16];[m
[31m-                        if (s_axi_wstrb[3] && GPIO_WIDTH > 24) gpio_data_reg[0][31:24] <= s_axi_wdata[31:24];[m
[31m-                    end[m
[31m-                    2'b01: begin  // Channel 0 Direction Register[m
[31m-                        if (s_axi_wstrb[0]) gpio_dir_reg[0][7:0] <= s_axi_wdata[7:0];[m
[31m-                        if (s_axi_wstrb[1] && GPIO_WIDTH > 8) gpio_dir_reg[0][15:8] <= s_axi_wdata[15:8];[m
[31m-                        if (s_axi_wstrb[2] && GPIO_WIDTH > 16) gpio_dir_reg[0][23:16] <= s_axi_wdata[23:16];[m
[31m-                        if (s_axi_wstrb[3] && GPIO_WIDTH > 24) gpio_dir_reg[0][31:24] <= s_axi_wdata[31:24];[m
[31m-                    end[m
[31m-                    2'b10: begin  // Channel 1 Data Register[m
[31m-                        if (NUM_CHANNELS > 1) begin[m
[31m-                            if (s_axi_wstrb[0]) gpio_data_reg[1][7:0] <= s_axi_wdata[7:0];[m
[31m-                            if (s_axi_wstrb[1] && GPIO_WIDTH > 8) gpio_data_reg[1][15:8] <= s_axi_wdata[15:8];[m
[31m-                            if (s_axi_wstrb[2] && GPIO_WIDTH > 16) gpio_data_reg[1][23:16] <= s_axi_wdata[23:16];[m
[31m-                            if (s_axi_wstrb[3] && GPIO_WIDTH > 24) gpio_data_reg[1][31:24] <= s_axi_wdata[31:24];[m
[31m-                        end[m
[31m-                    end[m
[31m-                    2'b11: begin  // Channel 1 Direction Register[m
[31m-                        if (NUM_CHANNELS > 1) begin[m
[31m-                            if (s_axi_wstrb[0]) gpio_dir_reg[1][7:0] <= s_axi_wdata[7:0];[m
[31m-                            if (s_axi_wstrb[1] && GPIO_WIDTH > 8) gpio_dir_reg[1][15:8] <= s_axi_wdata[15:8];[m
[31m-                            if (s_axi_wstrb[2] && GPIO_WIDTH > 16) gpio_dir_reg[1][23:16] <= s_axi_wdata[23:16];[m
[31m-                            if (s_axi_wstrb[3] && GPIO_WIDTH > 24) gpio_dir_reg[1][31:24] <= s_axi_wdata[31:24];[m
[31m-                        end[m
[31m-                    end[m
[31m-                endcase[m
[31m-            end[m
[31m-        end[m
[31m-    end[m
[31m-    [m
[31m-    // AXI4-Lite Write Response Channel[m
[31m-    always_ff @(posedge aclk) begin[m
[31m-        if (!aresetn) begin[m
[31m-            axi_bvalid <= 1'b0;[m
[31m-            axi_bresp <= 2'b00;[m
[31m-        end else begin[m
[31m-            if (axi_awready && s_axi_awvalid && axi_wready && s_axi_wvalid && ~axi_bvalid) begin[m
[31m-                axi_bvalid <= 1'b1;[m
[31m-                axi_bresp <= 2'b00; // OKAY response[m
[31m-            end else begin[m
[31m-                if (s_axi_bready && axi_bvalid) begin[m
[31m-                    axi_bvalid <= 1'b0;[m
[31m-                end[m
[31m-            end[m
[31m-        end[m
[31m-    end[m
[31m-    [m
[31m-    // AXI4-Lite Read Address Channel[m
[31m-    always_ff @(posedge aclk) begin[m
[31m-        if (!aresetn) begin[m
[31m-            axi_arready <= 1'b0;[m
[31m-            axi_araddr <= '0;[m
[31m-        end else begin[m
[31m-            if (~axi_arready && s_axi_arvalid) begin[m
[31m-                axi_arready <= 1'b1;[m
[31m-                axi_araddr <= s_axi_araddr;[m
[31m-            end else begin[m
[31m-                axi_arready <= 1'b0;[m
[31m-            end[m
[31m-        end[m
[31m-    end[m
[31m-    [m
[31m-    // AXI4-Lite Read Data Channel[m
[31m-    always_ff @(posedge aclk) begin[m
[31m-        if (!aresetn) begin[m
[31m-            axi_rvalid <= 1'b0;[m
[31m-            axi_rresp <= 2'b00;[m
[31m-        end else begin[m
[31m-            if (axi_arready && s_axi_arvalid && ~axi_rvalid) begin[m
[31m-                axi_rvalid <= 1'b1;[m
[31m-                axi_rresp <= 2'b00; // OKAY response[m
[31m-            end else begin[m
[31m-                if (axi_rvalid && s_axi_rready) begin[m
[31m-                    axi_rvalid <= 1'b0;[m
[31m-                end[m
[31m-            end[m
[31m-        end[m
[31m-    end[m
[31m-    [m
[31m-    // Register reads[m
[31m-    always_ff @(posedge aclk) begin[m
[31m-        if (!aresetn) begin[m
[31m-            axi_rdata <= '0;[m
[31m-        end else begin[m
[31m-            if (axi_arready && s_axi_arvalid && ~axi_rvalid) begin[m
[31m-                case (axi_araddr[3:2])[m
[31m-                    2'b00: begin  // Channel 0 Data Register[m
[31m-                        axi_rdata <= '0;[m
[31m-                        // For inputs, read from gpio_i; for outputs, read from gpio_data_reg[m
[31m-                        for (int i = 0; i < GPIO_WIDTH; i++) begin[m
[31m-                            axi_rdata[i] <= gpio_dir_reg[0][i] ? gpio_data_reg[0][i] : gpio_i[0][i];[m
[31m-                        end[m
[31m-                    end[m
[31m-                    2'b01: begin  // Channel 0 Direction Register[m
[31m-                        axi_rdata <= '0;[m
[31m-                        axi_rdata[GPIO_WIDTH-1:0] <= gpio_dir_reg[0];[m
[31m-                    end[m
[31m-                    2'b10: begin  // Channel 1 Data Register[m
[31m-                        axi_rdata <= '0;[m
[31m-                        if (NUM_CHANNELS > 1) begin[m
[31m-                            for (int i = 0; i < GPIO_WIDTH; i++) begin[m
[31m-                                axi_rdata[i] <= gpio_dir_reg[1][i] ? gpio_data_reg[1][i] : gpio_i[1][i];[m
[31m-                            end[m
[31m-                        end[m
[31m-                    end[m
[31m-                    2'b11: begin  // Channel 1 Direction Register[m
[31m-                        axi_rdata <= '0;[m
[31m-                        if (NUM_CHANNELS > 1) begin[m
[31m-                            axi_rdata[GPIO_WIDTH-1:0] <= gpio_dir_reg[1];[m
[31m-                        end[m
[31m-                    end[m
[31m-                endcase[m
[31m-            end[m
[31m-        end[m
[31m-    end[m
[31m-    [m
[31m-    // GPIO output assignments[m
[31m-    generate[m
[31m-        for (genvar ch = 0; ch < NUM_CHANNELS; ch++) begin : gen_gpio_channels[m
[31m-            assign gpio_o[ch] = gpio_data_reg[ch];[m
[31m-            assign gpio_t[ch] = ~gpio_dir_reg[ch];  // Invert: 1=input (tristate), 0=output[m
[31m-        end[m
[31m-    endgenerate[m
[31m-    [m
[31m-    // Assign outputs[m
[31m-    assign s_axi_awready = axi_awready;[m
[31m-    assign s_axi_wready = axi_wready;[m
[31m-    assign s_axi_bresp = axi_bresp;[m
[31m-    assign s_axi_bvalid = axi_bvalid;[m
[31m-    assign s_axi_arready = axi_arready;[m
[31m-    assign s_axi_rdata = axi_rdata;[m
[31m-    assign s_axi_rresp = axi_rresp;[m
[31m-    assign s_axi_rvalid = axi_rvalid;[m
[31m-[m
[31m-endmodule[m
\ No newline at end of file[m
[1mdiff --git a/ip_cores/axi_lite_gpio/rtl/axi_lite_gpio.v b/ip_cores/axi_lite_gpio/rtl/axi_lite_gpio.v[m
[1mnew file mode 100644[m
[1mindex 0000000..6c9a07b[m
[1m--- /dev/null[m
[1m+++ b/ip_cores/axi_lite_gpio/rtl/axi_lite_gpio.v[m
[36m@@ -0,0 +1,298 @@[m
[32m+[m[32m/*[m
[32m+[m[32m * AXI4-Lite GPIO Controller[m
[32m+[m[32m *[m[41m [m
[32m+[m[32m * This module implements a configurable GPIO controller with AXI4-Lite slave interface.[m
[32m+[m[32m * Features:[m
[32m+[m[32m * - Configurable width (1 to 32 bits) and direction at compile time[m
[32m+[m[32m * - Support for up to 2 channels[m
[32m+[m[32m * - Individual pin direction control (input/output)[m
[32m+[m[32m * - AXI4-Lite compliant slave interface[m
[32m+[m[32m *[m[41m [m
[32m+[m[32m * Register Map:[m
[32m+[m[32m * 0x00: Channel 0 Data Register (R/W)[m
[32m+[m[32m * 0x04: Channel 0 Direction Register (R/W) - 1=output, 0=input[m
[32m+[m[32m * 0x08: Channel 1 Data Register (R/W) - if NUM_CHANNELS > 1[m
[32m+[m[32m * 0x0C: Channel 1 Direction Register (R/W) - if NUM_CHANNELS > 1[m
[32m+[m[32m */[m
[32m+[m
[32m+[m[32mmodule axi_lite_gpio #([m
[32m+[m[32m    parameter GPIO_WIDTH = 8,           // Width of each GPIO channel (1-32)[m
[32m+[m[32m    parameter NUM_CHANNELS = 1,         // Number of GPIO channels (1-2)[m
[32m+[m[32m    parameter ADDR_WIDTH = 4            // AXI address width (minimum 4 for register map)[m
[32m+[m[32m) ([m
[32m+[m[32m    // Clock and Reset[m
[32m+[m[32m    input                           aclk,[m
[32m+[m[32m    input                           aresetn,[m
[32m+[m[41m    [m
[32m+[m[32m    // AXI4-Lite Slave Interface[m
[32m+[m[32m    // Write Address Channel[m
[32m+[m[32m    input  [ADDR_WIDTH-1:0]         s_axi_awaddr,[m
[32m+[m[32m    input  [2:0]                    s_axi_awprot,[m
[32m+[m[32m    input                           s_axi_awvalid,[m
[32m+[m[32m    output                          s_axi_awready,[m
[32m+[m[41m    [m
[32m+[m[32m    // Write Data Channel[m[41m  [m
[32m+[m[32m    input  [31:0]                   s_axi_wdata,[m
[32m+[m[32m    input  [3:0]                    s_axi_wstrb,[m
[32m+[m[32m    input                           s_axi_wvalid,[m
[32m+[m[32m    output                          s_axi_wready,[m
[32m+[m[41m    [m
[32m+[m[32m    // Write Response Channel[m
[32m+[m[32m    output [1:0]                    s_axi_bresp,[m
[32m+[m[32m    output                          s_axi_bvalid,[m
[32m+[m[32m    input                           s_axi_bready,[m
[32m+[m[41m    [m
[32m+[m[32m    // Read Address Channel[m
[32m+[m[32m    input  [ADDR_WIDTH-1:0]         s_axi_araddr,[m
[32m+[m[32m    input  [2:0]                    s_axi_arprot,[m
[32m+[m[32m    input                           s_axi_arvalid,[m
[32m+[m[32m    output                          s_axi_arready,[m
[32m+[m[41m    [m
[32m+[m[32m    // Read Data Channel[m
[32m+[m[32m    output [31:0]                   s_axi_rdata,[m
[32m+[m[32m    output [1:0]                    s_axi_rresp,[m
[32m+[m[32m    output                          s_axi_rvalid,[m
[32m+[m[32m    input                           s_axi_rready,[m
[32m+[m[41m    [m
[32m+[m[32m    // GPIO Interface[m
[32m+[m[32m    input  [GPIO_WIDTH*NUM_CHANNELS-1:0]  gpio_i,   // GPIO input[m
[32m+[m[32m    output [GPIO_WIDTH*NUM_CHANNELS-1:0]  gpio_o,   // GPIO output[m[41m  [m
[32m+[m[32m    output [GPIO_WIDTH*NUM_CHANNELS-1:0]  gpio_t    // GPIO tristate (1=input, 0=output)[m
[32m+[m[32m);[m
[32m+[m
[32m+[m[32m    // Parameter validation[m
[32m+[m[32m    initial begin[m
[32m+[m[32m        if (GPIO_WIDTH < 1 || GPIO_WIDTH > 32) begin[m
[32m+[m[32m            $error("GPIO_WIDTH must be between 1 and 32, got %0d", GPIO_WIDTH);[m
[32m+[m[32m        end[m
[32m+[m[32m        if (NUM_CHANNELS < 1 || NUM_CHANNELS > 2) begin[m
[32m+[m[32m            $error("NUM_CHANNELS must be 1 or 2, got %0d", NUM_CHANNELS);[m
[32m+[m[32m        end[m
[32m+[m[32m        if (ADDR_WIDTH < 4) begin[m
[32m+[m[32m            $error("ADDR_WIDTH must be at least 4 for register map, got %0d", ADDR_WIDTH);[m
[32m+[m[32m        end[m
[32m+[m[32m    end[m
[32m+[m
[32m+[m[32m    // Internal registers[m
[32m+[m[32m    reg [GPIO_WIDTH*NUM_CHANNELS-1:0] gpio_data_reg;  // Data registers[m
[32m+[m[32m    reg [GPIO_WIDTH*NUM_CHANNELS-1:0] gpio_dir_reg;   // Direction registers (1=output, 0=input)[m
[32m+[m[41m    [m
[32m+[m[32m    // AXI4-Lite interface signals[m
[32m+[m[32m    reg                  axi_awready;[m
[32m+[m[32m    reg                  axi_wready;[m
[32m+[m[32m    reg [1:0]            axi_bresp;[m
[32m+[m[32m    reg                  axi_bvalid;[m
[32m+[m[32m    reg                  axi_arready;[m
[32m+[m[32m    reg [31:0]           axi_rdata;[m
[32m+[m[32m    reg [1:0]            axi_rresp;[m
[32m+[m[32m    reg                  axi_rvalid;[m
[32m+[m[41m    [m
[32m+[m[32m    // Internal address registers[m
[32m+[m[32m    reg [ADDR_WIDTH-1:0] axi_awaddr;[m
[32m+[m[32m    reg [ADDR_WIDTH-1:0] axi_araddr;[m
[32m+[m[41m    [m
[32m+[m[32m    // AXI4-Lite Write Address Channel[m
[32m+[m[32m    always @(posedge aclk) begin[m
[32m+[m[32m        if (!aresetn) begin[m
[32m+[m[32m            axi_awready <= 1'b0;[m
[32m+[m[32m            axi_awaddr <= {ADDR_WIDTH{1'b0}};[m
[32m+[m[32m        end else begin[m
[32m+[m[32m            if (~axi_awready && s_axi_awvalid && s_axi_wvalid) begin[m
[32m+[m[32m                axi_awready <= 1'b1;[m
[32m+[m[32m                axi_awaddr <= s_axi_awaddr;[m
[32m+[m[32m            end else begin[m
[32m+[m[32m                axi_awready <= 1'b0;[m
[32m+[m[32m            end[m
[32m+[m[32m        end[m
[32m+[m[32m    end[m
[32m+[m[41m    [m
[32m+[m[32m    // AXI4-Lite Write Data Channel[m
[32m+[m[32m    always @(posedge aclk) begin[m
[32m+[m[32m        if (!aresetn) begin[m
[32m+[m[32m            axi_wready <= 1'b0;[m
[32m+[m[32m        end else begin[m
[32m+[m[32m            if (~axi_wready && s_axi_wvalid && s_axi_awvalid) begin[m
[32m+[m[32m                axi_wready <= 1'b1;[m
[32m+[m[32m            end else begin[m
[32m+[m[32m                axi_wready <= 1'b0;[m
[32m+[m[32m            end[m
[32m+[m[32m        end[m
[32m+[m[32m    end[m
[32m+[m[41m    [m
[32m+[m[32m    // Register writes[m
[32m+[m[32m    integer ch_idx;[m
[32m+[m[32m    always @(posedge aclk) begin[m
[32m+[m[32m        if (!aresetn) begin[m
[32m+[m[32m            gpio_data_reg <= {GPIO_WIDTH*NUM_CHANNELS{1'b0}};[m
[32m+[m[32m            gpio_dir_reg <= {GPIO_WIDTH*NUM_CHANNELS{1'b0}};  // Default to all inputs[m
[32m+[m[32m        end else begin[m
[32m+[m[32m            if (axi_wready && s_axi_wvalid && axi_awready && s_axi_awvalid) begin[m
[32m+[m[32m                case (axi_awaddr[3:2])[m
[32m+[m[32m                    2'b00: begin  // Channel 0 Data Register[m
[32m+[m[32m                        if (s_axi_wstrb[0])[m[41m [m
[32m+[m[32m                            gpio_data_reg[7:0] <= s_axi_wdata[7:0];[m
[32m+[m[32m                        if (s_axi_wstrb[1] && GPIO_WIDTH > 8)[m[41m [m
[32m+[m[32m                            gpio_data_reg[15:8] <= s_axi_wdata[15:8];[m
[32m+[m[32m                        if (s_axi_wstrb[2] && GPIO_WIDTH > 16)[m[41m [m
[32m+[m[32m                            gpio_data_reg[23:16] <= s_axi_wdata[23:16];[m
[32m+[m[32m                        if (s_axi_wstrb[3] && GPIO_WIDTH > 24)[m[41m [m
[32m+[m[32m                            gpio_data_reg[31:24] <= s_axi_wdata[31:24];[m
[32m+[m[32m                    end[m
[32m+[m[32m                    2'b01: begin  // Channel 0 Direction Register[m
[32m+[m[32m                        if (s_axi_wstrb[0])[m[41m [m
[32m+[m[32m                            gpio_dir_reg[7:0] <= s_axi_wdata[7:0];[m
[32m+[m[32m                        if (s_axi_wstrb[1] && GPIO_WIDTH > 8)[m[41m [m
[32m+[m[32m                            gpio_dir_reg[15:8] <= s_axi_wdata[15:8];[m
[32m+[m[32m                        if (s_axi_wstrb[2] && GPIO_WIDTH > 16)[m[41m [m
[32m+[m[32m                            gpio_dir_reg[23:16] <= s_axi_wdata[23:16];[m
[32m+[m[32m                        if (s_axi_wstrb[3] && GPIO_WIDTH > 24)[m[41m [m
[32m+[m[32m                            gpio_dir_reg[31:24] <= s_axi_wdata[31:24];[m
[32m+[m[32m                    end[m
[32m+[m[32m                    2'b10: begin  // Channel 1 Data Register[m
[32m+[m[32m                        if (NUM_CHANNELS > 1) begin[m
[32m+[m[32m                            if (s_axi_wstrb[0])[m[41m [m
[32m+[m[32m                                gpio_data_reg[GPIO_WIDTH+7:GPIO_WIDTH] <= s_axi_wdata[7:0];[m
[32m+[m[32m                            if (s_axi_wstrb[1] && GPIO_WIDTH > 8)[m[41m [m
[32m+[m[32m                                gpio_data_reg[GPIO_WIDTH+15:GPIO_WIDTH+8] <= s_axi_wdata[15:8];[m
[32m+[m[32m                            if (s_axi_wstrb[2] && GPIO_WIDTH > 16)[m[41m [m
[32m+[m[32m                                gpio_data_reg[GPIO_WIDTH+23:GPIO_WIDTH+16] <= s_axi_wdata[23:16];[m
[32m+[m[32m                            if (s_axi_wstrb[3] && GPIO_WIDTH > 24)[m[41m [m
[32m+[m[32m                                gpio_data_reg[GPIO_WIDTH+31:GPIO_WIDTH+24] <= s_axi_wdata[31:24];[m
[32m+[m[32m                        end[m
[32m+[m[32m                    end[m
[32m+[m[32m                    2'b11: begin  // Channel 1 Direction Register[m
[32m+[m[32m                        if (NUM_CHANNELS > 1) begin[m
[32m+[m[32m                            if (s_axi_wstrb[0])[m[41m [m
[32m+[m[32m                                gpio_dir_reg[GPIO_WIDTH+7:GPIO_WIDTH] <= s_axi_wdata[7:0];[m
[32m+[m[32m                            if (s_axi_wstrb[1] && GPIO_WIDTH > 8)[m[41m [m
[32m+[m[32m                                gpio_dir_reg[GPIO_WIDTH+15:GPIO_WIDTH+8] <= s_axi_wdata[15:8];[m
[32m+[m[32m                            if (s_axi_wstrb[2] && GPIO_WIDTH > 16)[m[41m [m
[32m+[m[32m                                gpio_dir_reg[GPIO_WIDTH+23:GPIO_WIDTH+16] <= s_axi_wdata[23:16];[m
[32m+[m[32m                            if (s_axi_wstrb[3] && GPIO_WIDTH > 24)[m[41m [m
[32m+[m[32m                                gpio_dir_reg[GPIO_WIDTH+31:GPIO_WIDTH+24] <= s_axi_wdata[31:24];[m
[32m+[m[32m                        end[m
[32m+[m[32m                    end[m
[32m+[m[32m                endcase[m
[32m+[m[32m            end[m
[32m+[m[32m        end[m
[32m+[m[32m    end[m
[32m+[m[41m    [m
[32m+[m[32m    // AXI4-Lite Write Response Channel[m
[32m+[m[32m    always @(posedge aclk) begin[m
[32m+[m[32m        if (!aresetn) begin[m
[32m+[m[32m            axi_bvalid <= 1'b0;[m
[32m+[m[32m            axi_bresp <= 2'b00;[m
[32m+[m[32m        end else begin[m
[32m+[m[32m            if (axi_awready && s_axi_awvalid && axi_wready && s_axi_wvalid && ~axi_bvalid) begin[m
[32m+[m[32m                axi_bvalid <= 1'b1;[m
[32m+[m[32m                axi_bresp <= 2'b00; // OKAY response[m
[32m+[m[32m            end else begin[m
[32m+[m[32m                if (s_axi_bready && axi_bvalid) begin[m
[32m+[m[32m                    axi_bvalid <= 1'b0;[m
[32m+[m[32m                end[m
[32m+[m[32m            end[m
[32m+[m[32m        end[m
[32m+[m[32m    end[m
[32m+[m[41m    [m
[32m+[m[32m    // AXI4-Lite Read Address Channel[m
[32m+[m[32m    always @(posedge aclk) begin[m
[32m+[m[32m        if (!aresetn) begin[m
[32m+[m[32m            axi_arready <= 1'b0;[m
[32m+[m[32m            axi_araddr <= {ADDR_WIDTH{1'b0}};[m
[32m+[m[32m        end else begin[m
[32m+[m[32m            if (~axi_arready && s_axi_arvalid) begin[m
[32m+[m[32m                axi_arready <= 1'b1;[m
[32m+[m[32m                axi_araddr <= s_axi_araddr;[m
[32m+[m[32m            end else begin[m
[32m+[m[32m                axi_arready <= 1'b0;[m
[32m+[m[32m            end[m
[32m+[m[32m        end[m
[32m+[m[32m    end[m
[32m+[m[41m    [m
[32m+[m[32m    // AXI4-Lite Read Data Channel[m
[32m+[m[32m    always @(posedge aclk) begin[m
[32m+[m[32m        if (!aresetn) begin[m
[32m+[m[32m            axi_rvalid <= 1'b0;[m
[32m+[m[32m            axi_rresp <= 2'b00;[m
[32m+[m[32m        end else begin[m
[32m+[m[32m            if (axi_arready && s_axi_arvalid && ~axi_rvalid) begin[m
[32m+[m[32m                axi_rvalid <= 1'b1;[m
[32m+[m[32m                axi_rresp <= 2'b00; // OKAY response[m
[32m+[m[32m            end else begin[m
[32m+[m[32m                if (axi_rvalid && s_axi_rready) begin[m
[32m+[m[32m                    axi_rvalid <= 1'b0;[m
[32m+[m[32m                end[m
[32m+[m[32m            end[m
[32m+[m[32m        end[m
[32m+[m[32m    end[m
[32m+[m[41m    [m
[32m+[m[32m    // Register reads[m
[32m+[m[32m    integer i;[m
[32m+[m[32m    always @(posedge aclk) begin[m
[32m+[m[32m        if (!aresetn) begin[m
[32m+[m[32m            axi_rdata <= 32'h00000000;[m
[32m+[m[32m        end else begin[m
[32m+[m[32m            if (axi_arready && s_axi_arvalid && ~axi_rvalid) begin[m
[32m+[m[32m                case (axi_araddr[3:2])[m
[32m+[m[32m                    2'b00: begin  // Channel 0 Data Register[m
[32m+[m[32m                        axi_rdata <= 32'h00000000;[m
[32m+[m[32m                        // For inputs, read from gpio_i; for outputs, read from gpio_data_reg[m
[32m+[m[32m                        for (i = 0; i < GPIO_WIDTH; i = i + 1) begin[m
[32m+[m[32m                            if (i < 32) begin[m
[32m+[m[32m                                axi_rdata[i] <= gpio_dir_reg[i] ? gpio_data_reg[i] : gpio_i[i];[m
[32m+[m[32m                            end[m
[32m+[m[32m                        end[m
[32m+[m[32m                    end[m
[32m+[m[32m                    2'b01: begin  // Channel 0 Direction Register[m
[32m+[m[32m                        axi_rdata <= 32'h00000000;[m
[32m+[m[32m                        if (GPIO_WIDTH <= 32) begin[m
[32m+[m[32m                            axi_rdata[GPIO_WIDTH-1:0] <= gpio_dir_reg[GPIO_WIDTH-1:0];[m
[32m+[m[32m                        end else begin[m
[32m+[m[32m                            axi_rdata[31:0] <= gpio_dir_reg[31:0];[m
[32m+[m[32m                        end[m
[32m+[m[32m                    end[m
[32m+[m[32m                    2'b10: begin  // Channel 1 Data Register[m
[32m+[m[32m                        axi_rdata <= 32'h00000000;[m
[32m+[m[32m                        if (NUM_CHANNELS > 1) begin[m
[32m+[m[32m                            for (i = 0; i < GPIO_WIDTH; i = i + 1) begin[m
[32m+[m[32m                                if (i < 32) begin[m
[32m+[m[32m                                    axi_rdata[i] <= gpio_dir_reg[GPIO_WIDTH+i] ? gpio_data_reg[GPIO_WIDTH+i] : gpio_i[GPIO_WIDTH+i];[m
[32m+[m[32m                                end[m
[32m+[m[32m                            end[m
[32m+[m[32m                        end[m
[32m+[m[32m                    end[m
[32m+[m[32m                    2'b11: begin  // Channel 1 Direction Register[m
[32m+[m[32m                        axi_rdata <= 32'h00000000;[m
[32m+[m[32m                        if (NUM_CHANNELS > 1) begin[m
[32m+[m[32m                            if (GPIO_WIDTH <= 32) begin[m
[32m+[m[32m                                axi_rdata[GPIO_WIDTH-1:0] <= gpio_dir_reg[GPIO_WIDTH*2-1:GPIO_WIDTH];[m
[32m+[m[32m                            end else begin[m
[32m+[m[32m                                axi_rdata[31:0] <= gpio_dir_reg[GPIO_WIDTH+31:GPIO_WIDTH];[m
[32m+[m[32m                            end[m
[32m+[m[32m                        end[m
[32m+[m[32m                    end[m
[32m+[m[32m                endcase[m
[32m+[m[32m            end[m
[32m+[m[32m        end[m
[32m+[m[32m    end[m
[32m+[m[41m    [m
[32m+[m[32m    // GPIO output assignments[m
[32m+[m[32m    generate[m
[32m+[m[32m        genvar ch;[m
[32m+[m[32m        for (ch = 0; ch < NUM_CHANNELS; ch = ch + 1) begin : gen_gpio_channels[m
[32m+[m[32m            assign gpio_o[GPIO_WIDTH*(ch+1)-1:GPIO_WIDTH*ch] = gpio_data_reg[GPIO_WIDTH*(ch+1)-1:GPIO_WIDTH*ch];[m
[32m+[m[32m            assign gpio_t[GPIO_WIDTH*(ch+1)-1:GPIO_WIDTH*ch] = ~gpio_dir_reg[GPIO_WIDTH*(ch+1)-1:GPIO_WIDTH*ch];  // Invert: 1=input (tristate), 0=output[m
[32m+[m[32m        end[m
[32m+[m[32m    endgenerate[m
[32m+[m[41m    [m
[32m+[m[32m    // Assign outputs[m
[32m+[m[32m    assign s_axi_awready = axi_awready;[m
[32m+[m[32m    assign s_axi_wready = axi_wready;[m
[32m+[m[32m    assign s_axi_bresp = axi_bresp;[m
[32m+[m[32m    assign s_axi_bvalid = axi_bvalid;[m
[32m+[m[32m    assign s_axi_arready = axi_arready;[m
[32m+[m[32m    assign s_axi_rdata = axi_rdata;[m
[32m+[m[32m    assign s_axi_rresp = axi_rresp;[m
[32m+[m[32m    assign s_axi_rvalid = axi_rvalid;[m
[32m+[m
[32m+[m[32mendmodule[m
\ No newline at end of file[m
